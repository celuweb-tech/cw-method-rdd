---
version: 2.0.0
description: Reglas de testing - Test-First con patrones exactos, sin iteración
globs:
  - "test/**/*.dart"
  - "lib/**/*.dart"
alwaysApply: true
---

# Reglas de Testing

## Estrategia (OBLIGATORIO)

> **TEST-FIRST SIN ITERACIÓN**: Escribir tests correctos A LA PRIMERA usando los patrones de este documento.
>
> 1. **IDENTIFICAR**: Qué componente es
> 2. **COPIAR PATRÓN**: Usar el patrón EXACTO de esta guía
> 3. **ADAPTAR**: Solo cambiar nombres y datos específicos
> 4. **EJECUTAR**: `flutter test` una sola vez

**⛔ PROHIBIDO ITERAR**: NO experimentar con sintaxis alternativas.

## Reglas Fundamentales

- SIEMPRE usar `ResultFactory.success()` / `ResultFactory.failure()` 
- SIEMPRE usar `HttpRequestFailure` (`.network()`, `.server()`, `.badRequest()`, `.unauthorized()`, `.validation()`)
- SIEMPRE usar `addTearDown(container.dispose)` para ProviderContainer
- NUNCA usar `Right`/`Left` de dartz
- NUNCA iterar buscando sintaxis

## Qué DEBE Tener Tests

| Componente | ¿Test? |
|------------|--------|
| Use Cases | ✅ SÍ |
| Repositories Impl | ✅ SÍ |
| Controllers | ✅ SÍ |
| Providers | ✅ SÍ |
| Models | ✅ SÍ |
| Entities | ✅ SÍ |
| Pages | ✅ SÍ |
| DataSources | ✅ SÍ |
| Widgets con lógica | ✅ SÍ |

## Qué NO Requiere Tests

- `main.dart`
- Archivos generados (`*.g.dart`, `*.freezed.dart`)
- Contratos/Interfaces (Repository abstracto, DataSource abstracto)
- Widgets 100% estáticos

---

# PATRONES EXACTOS

## 1. Entity Test

```dart
import 'package:flutter_test/flutter_test.dart';

void main() {
  group('StoreEntity', () {
    test('Given values, when created, then should have correct properties', () {
      //Given
      //When
      const entity = StoreEntity(id: '1', name: 'Store', city: 'Bogotá');

      //Then
      expect(entity.id, equals('1'));
      expect(entity.name, equals('Store'));
    });

    test('Given same values, when compared, then should be equal', () {
      //Given
      const entity1 = StoreEntity(id: '1', name: 'Store', city: 'Bogotá');
      const entity2 = StoreEntity(id: '1', name: 'Store', city: 'Bogotá');

      //Then
      expect(entity1, equals(entity2));
    });

    test('Given entity, when copyWith, then should update specified fields', () {
      //Given
      const entity = StoreEntity(id: '1', name: 'Store', city: 'Bogotá');

      //When
      final updated = entity.copyWith(name: 'New Store');

      //Then
      expect(updated.id, equals('1'));
      expect(updated.name, equals('New Store'));
    });
  });
}
```

## 2. Model Test

```dart
import 'package:flutter_test/flutter_test.dart';

void main() {
  group('StoreModel', () {
    test('Given JSON, when fromJson, then should create model', () {
      //Given
      final json = {'id': 1, 'name': 'Store', 'city': 'Bogotá'};

      //When
      final model = StoreModel.fromJson(json);

      //Then
      expect(model.id, equals(1));
      expect(model.name, equals('Store'));
    });

    test('Given model, when toJson, then should create correct map', () {
      //Given
      const model = StoreModel(id: 1, name: 'Store', city: 'Bogotá');

      //When
      final json = model.toJson();

      //Then
      expect(json['id'], equals(1));
      expect(json['name'], equals('Store'));
    });

    test('Given model, when toEntity, then should map correctly', () {
      //Given
      const model = StoreModel(id: 1, name: 'Store', city: 'Bogotá');

      //When
      final entity = model.toEntity();

      //Then
      expect(entity, isA<StoreEntity>());
      expect(entity.id, equals('1'));
    });
  });
}
```

## 3. UseCase Test

```dart
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';

import 'get_stores_usecase_test.mocks.dart';

@GenerateNiceMocks([MockSpec<StoresRepository>()])
void main() {
  group('GetStoresUseCase', () {
    late GetStoresUseCase useCase;
    late MockStoresRepository mockRepository;

    setUp(() {
      mockRepository = MockStoresRepository();
      useCase = GetStoresUseCase(mockRepository);
    });

    test('Given stores exist, when called, then should return success', () async {
      //Given
      when(mockRepository.getStores()).thenAnswer(
        (_) async => ResultFactory.success(mockResponse),
      );

      //When
      final result = await useCase();

      //Then
      expect(result.isSuccess, true);
      verify(mockRepository.getStores()).called(1);
    });

    test('Given network error, when called, then should return failure', () async {
      //Given
      when(mockRepository.getStores()).thenAnswer(
        (_) async => ResultFactory.failure(const HttpRequestFailure.network()),
      );

      //When
      final result = await useCase();

      //Then
      expect(result.isFailure, true);
    });
  });
}
```

## 4. Repository Test

```dart
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';

import 'stores_repository_impl_test.mocks.dart';

@GenerateNiceMocks([MockSpec<StoresRemoteDataSource>()])
void main() {
  group('StoresRepositoryImpl', () {
    late StoresRepositoryImpl repository;
    late MockStoresRemoteDataSource mockDataSource;

    setUp(() {
      mockDataSource = MockStoresRemoteDataSource();
      repository = StoresRepositoryImpl(mockDataSource);
    });

    test('Given datasource returns data, when getStores, then should return success', () async {
      //Given
      when(mockDataSource.getStores()).thenAnswer((_) async => mockResponse);

      //When
      final result = await repository.getStores();

      //Then
      expect(result.isSuccess, true);
      verify(mockDataSource.getStores()).called(1);
    });

    test('Given datasource throws, when getStores, then should return failure', () async {
      //Given
      when(mockDataSource.getStores()).thenThrow(Exception('Error'));

      //When
      final result = await repository.getStores();

      //Then
      expect(result.isFailure, true);
      expect(result.failure, isA<HttpRequestFailure>());
    });
  });
}
```

## 5. DataSource Test

```dart
import 'package:dio/dio.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';

import 'stores_remote_data_source_test.mocks.dart';

@GenerateNiceMocks([MockSpec<Dio>()])
void main() {
  group('StoresRemoteDataSource', () {
    late StoresRemoteDataSource dataSource;
    late MockDio mockDio;

    setUp(() {
      mockDio = MockDio();
      dataSource = StoresRemoteDataSource(mockDio);
    });

    test('Given successful response, when getStores, then should return model', () async {
      //Given
      when(mockDio.post(any, data: anyNamed('data'))).thenAnswer(
        (_) async => Response(
          data: responseData,
          statusCode: 200,
          requestOptions: RequestOptions(path: ''),
        ),
      );

      //When
      final result = await dataSource.getStores();

      //Then
      expect(result, isA<StoresResponseModel>());
    });

    test('Given DioException, when getStores, then should throw', () async {
      //Given
      when(mockDio.post(any, data: anyNamed('data'))).thenThrow(
        DioException(requestOptions: RequestOptions(path: '')),
      );

      //Then
      expect(() => dataSource.getStores(), throwsA(isA<DioException>()));
    });
  });
}
```

## 6. Controller Test

```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';

import 'stores_controller_test.mocks.dart';

@GenerateNiceMocks([MockSpec<GetStoresUseCase>()])
void main() {
  group('StoresController', () {
    late MockGetStoresUseCase mockUseCase;

    setUp(() {
      mockUseCase = MockGetStoresUseCase();
    });

    test('Given controller created, when read, then initial state is loading', () {
      //Given
      when(mockUseCase(
        page: anyNamed('page'),
        pageSize: anyNamed('pageSize'),
        searchQuery: anyNamed('searchQuery'),
      )).thenAnswer((_) async => ResultFactory.success(mockResponse));

      final container = ProviderContainer(
        overrides: [useCaseProvider.overrideWithValue(mockUseCase)],
      );
      addTearDown(container.dispose);

      //When
      final state = container.read(controllerProvider);

      //Then
      expect(state.isLoading, true);
    });

    test('Given success, when loadStores, then state has data', () async {
      //Given
      when(mockUseCase(
        page: anyNamed('page'),
        pageSize: anyNamed('pageSize'),
        searchQuery: anyNamed('searchQuery'),
      )).thenAnswer((_) async => ResultFactory.success(mockResponse));

      final container = ProviderContainer(
        overrides: [useCaseProvider.overrideWithValue(mockUseCase)],
      );
      addTearDown(container.dispose);

      //When
      await container.read(controllerProvider.notifier).loadStores();
      final state = container.read(controllerProvider);

      //Then
      expect(state.isLoading, false);
      expect(state.stores, isNotEmpty);
    });

    test('Given failure, when loadStores, then state has error', () async {
      //Given
      when(mockUseCase(
        page: anyNamed('page'),
        pageSize: anyNamed('pageSize'),
        searchQuery: anyNamed('searchQuery'),
      )).thenAnswer((_) async => ResultFactory.failure(const HttpRequestFailure.network()));

      final container = ProviderContainer(
        overrides: [useCaseProvider.overrideWithValue(mockUseCase)],
      );
      addTearDown(container.dispose);

      //When
      await container.read(controllerProvider.notifier).loadStores();
      final state = container.read(controllerProvider);

      //Then
      expect(state.error, isNotNull);
    });
  });
}
```

## 7. Providers Test

```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_test/flutter_test.dart';

void main() {
  group('Providers', () {
    late ProviderContainer container;

    setUp(() {
      container = ProviderContainer();
    });

    tearDown(() {
      container.dispose();
    });

    test('Given provider, when read, then should return correct type', () {
      //When
      final dataSource = container.read(dataSourceProvider);
      final repository = container.read(repositoryProvider);
      final useCase = container.read(useCaseProvider);

      //Then
      expect(dataSource, isA<StoresRemoteDataSource>());
      expect(repository, isA<StoresRepositoryImpl>());
      expect(useCase, isA<GetStoresUseCase>());
    });

    test('Given provider, when read twice, then should return same instance', () {
      //When
      final instance1 = container.read(repositoryProvider);
      final instance2 = container.read(repositoryProvider);

      //Then
      expect(identical(instance1, instance2), isTrue);
    });
  });
}
```

## 8. Page Test

```dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';

import 'stores_page_test.mocks.dart';

@GenerateNiceMocks([MockSpec<GetStoresUseCase>()])
void main() {
  group('StoresPage', () {
    late MockGetStoresUseCase mockUseCase;

    setUp(() {
      mockUseCase = MockGetStoresUseCase();
    });

    Widget createWidget() {
      return ProviderScope(
        overrides: [useCaseProvider.overrideWithValue(mockUseCase)],
        child: const MaterialApp(home: StoresPage()),
      );
    }

    testWidgets('Given error, when rendered, then shows error state', (tester) async {
      //Given
      when(mockUseCase(
        page: anyNamed('page'),
        pageSize: anyNamed('pageSize'),
        searchQuery: anyNamed('searchQuery'),
      )).thenAnswer((_) async => ResultFactory.failure(const HttpRequestFailure.network()));

      //When
      await tester.pumpWidget(createWidget());
      await tester.pumpAndSettle();

      //Then
      expect(find.byIcon(Icons.refresh), findsOneWidget);
    });

    testWidgets('Given empty, when rendered, then shows empty state', (tester) async {
      //Given
      when(mockUseCase(
        page: anyNamed('page'),
        pageSize: anyNamed('pageSize'),
        searchQuery: anyNamed('searchQuery'),
      )).thenAnswer((_) async => ResultFactory.success(emptyResponse));

      //When
      await tester.pumpWidget(createWidget());
      await tester.pumpAndSettle();

      //Then
      expect(find.byType(EmptyStateWidget), findsOneWidget);
    });

    testWidgets('Given data, when rendered, then shows list', (tester) async {
      //Given
      when(mockUseCase(
        page: anyNamed('page'),
        pageSize: anyNamed('pageSize'),
        searchQuery: anyNamed('searchQuery'),
      )).thenAnswer((_) async => ResultFactory.success(mockResponse));

      //When
      await tester.pumpWidget(createWidget());
      await tester.pumpAndSettle();

      //Then
      expect(find.byType(ListView), findsOneWidget);
    });
  });
}
```

## 9. Widget Test

```dart
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';

void main() {
  group('StoreCard', () {
    testWidgets('Given store, when rendered, then shows store info', (tester) async {
      //Given
      const store = StoreEntity(id: '1', name: 'Test Store', city: 'Bogotá');

      //When
      await tester.pumpWidget(
        MaterialApp(home: Scaffold(body: StoreCard(store: store))),
      );

      //Then
      expect(find.text('Test Store'), findsOneWidget);
      expect(find.text('Bogotá'), findsOneWidget);
    });

    testWidgets('Given store, when tapped, then calls onTap', (tester) async {
      //Given
      var tapped = false;
      const store = StoreEntity(id: '1', name: 'Test', city: 'Bogotá');

      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: StoreCard(store: store, onTap: () => tapped = true),
          ),
        ),
      );

      //When
      await tester.tap(find.byType(StoreCard));

      //Then
      expect(tapped, isTrue);
    });
  });
}
```

---

# PROHIBIDO

```dart
// ❌ NO usar dartz
Right(data) / Left(failure)
result.fold(...)

// ❌ NO olvidar dispose
final container = ProviderContainer();
// Sin addTearDown(container.dispose)

// ❌ NO usar thenReturn para Futures
when(mock.method()).thenReturn(data); // Usar thenAnswer

// ❌ NO verificar antes de ejecutar
verify(mock.method()).called(1);
await sut.method(); // Orden incorrecto
```